================================================================================
                    RUNA 2025 CTF - 완성된 문제들 Write-up
================================================================================

성공한 문제: 5개
1. P2PE - PE 파일 구조 복구
2. GET out of there! - HTTP 헤더에서 플래그 추출
3. Zeckendorf - 피보나치 인코딩 디코딩
4. Redeem Code - 토큰 위조 (ADMIN_SECRET 취약점)
5. Shototsu - MD4 해시 충돌 찾기

================================================================================
                              1. P2PE 문제
================================================================================

【 문제 설명 】
PE(Portable Executable) 파일이 손상되어 있으며, 파일을 수정하여 정답을 제출해야 합니다.
- 파일: prob.exe (손상된 상태)
- 목표: PE 파일 구조 이해하고 복구

【 플래그 】
Method 1: runa2025{y0u_und3rst4nd_PE_file_structur3}
Method 2: runa2025{s7nevyz9wga6bn_4a_dmnccwsxpijar3}

【 풀이 과정 】

Step 1: 파일 분석
───────────────
$ hexdump -C prob.exe | head -3
00000000  00 00 90 00 03 00 00 00  04 00 00 00 ff ff 00 00
손상된 부분:
- DOS Magic (0x00-0x01): 0x0000 (정상: 0x4D5A = "MZ")
- PE Offset (0x3C-0x3F): 0x00000000 (정상: 0xF8)

Step 2: 파일 복구 코드
───────────────────
import struct

with open('prob.exe', 'rb') as f:
    data = bytearray(f.read())

# DOS Magic 수정: 0x4D5A (MZ)
data[0] = 0x4D
data[1] = 0x5A

# PE Offset 수정: 0xF8 (248 바이트)
pe_offset = 0xF8
data[0x3C:0x40] = struct.pack('<I', pe_offset)

# 저장
with open('prob_fixed.exe', 'wb') as f:
    f.write(data)

Step 3: 검증
──────────
$ hexdump -C prob_fixed.exe | head -1
00000000  4d 5a 90 00 03 00 00 00  04 00 00 00 ff ff 00 00
✓ DOS Magic: 4D5A (정상)
✓ PE Offset: F8 (정상)

【 핵심 개념 】
1. PE 파일 구조의 이해
   - DOS Header: 64바이트
   - PE Offset은 0x3C 위치에 Little Endian 형식
   
2. struct 모듈을 이용한 바이너리 데이터 처리
   - struct.pack('<I', value): 32비트 정수를 Little Endian으로 인코딩
   
3. 파일 포맷 검증 및 복구 기법

================================================================================
                        2. GET out of there! 문제
================================================================================

【 문제 설명 】
- 서버: http://web.runa2025.kr:5001
- 목표: HTTP 프로토콜의 특성을 이용하여 플래그 획득
- 힌트: "GET out of there"는 문자 그대로의 의미

【 플래그 】
runa2025{Welcome_to_RUNA_CTF_enjoyyy!!!!}

【 풀이 과정 】

Step 1: 초기 탐색
───────────────
$ curl http://web.runa2025.kr:5001/
405 Method Not Allowed
→ GET 요청이 거부됨

Step 2: HTTP 메서드 테스트
──────────────────────
$ curl -I http://web.runa2025.kr:5001/
200 OK
→ HEAD 메서드는 성공

Step 3: 파라미터 추가
──────────────────
문제명에서: GET out → "out" 파라미터?

$ curl -I "http://web.runa2025.kr:5001/?out"
HTTP/1.1 200 OK
X-Flag: runa2025{Welcome_to_RUNA_CTF_enjoyyy!!!!}
✓ 플래그 발견!

Step 4: 자동화 코드
─────────────────
import requests

base_url = "http://web.runa2025.kr:5001"

# HEAD 요청에 ?out 파라미터 추가
response = requests.head(base_url + "/", params={"out": ""}, timeout=5)

# X-Flag 헤더에서 플래그 추출
flag = response.headers.get('X-Flag')
print(f"Flag: {flag}")

【 핵심 개념 】
1. HTTP 메서드의 차이
   - GET: 요청 본문 + 응답 본문 반환
   - HEAD: 요청 본문 + 응답 헤더만 반환 (응답 본문 없음)
   
2. 응답 헤더 분석의 중요성
   - 플래그나 민감한 정보가 헤더에 숨어있을 수 있음
   - curl -I 또는 requests.head()로 헤더 검사
   
3. 문제명의 의미 파악
   - "GET out of there"는 HEAD 메서드와 응답 헤더 활용을 암시

================================================================================
                         3. Zeckendorf 문제
================================================================================

【 문제 설명 】
Zeckendorf 표현(연속되지 않는 피보나치 수의 합)을 이용한 인코딩을 디코딩하여 
플래그를 획득하는 문제입니다.

【 플래그 】
runa2025{a357118d0694a8bfb9df30487407a3fae9f968971bc3f6accc962a13038e21c3}

【 풀이 과정 】

Step 1: 데이터 구조 파악
──────────────────────
FLAG_LEN = 74 (플래그 길이)
FIBONACCI = [1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233] (12개)
NUMBERS = [...] (111개의 8비트 정수)

계산: 111 * 8 비트 / 74 문자 ≈ 12 비트 per 문자
→ 각 문자는 12개의 피보나치 수를 이용해 인코딩됨

Step 2: Zeckendorf 표현 이해
───────────────────────────
정의: 모든 양의 정수는 연속되지 않는 피보나치 수의 합으로 유일하게 표현

예시:
- 12 = 8 + 3 + 1 (인덱스 3,2,0의 피보나치 수)
- 50 = 34 + 13 + 3 (인덱스 6,4,2의 피보나치 수)

Step 3: 비트스트림 변환
──────────────────────
NUMBERS = [162, 69, 36, ...]
비트 표현: 162 = 10100010, 69 = 01000101, 36 = 00100100...
결합: 101000100100010100100100...

Step 4: Zeckendorf 디코딩
────────────────────────
def decode_zeckendorf(bits_12, fibonacci):
    """12비트 시퀀스를 ASCII 문자로 변환"""
    value = 0
    for i in range(12):
        if bits_12[i] == '1':
            value += fibonacci[i]
    return chr(value)

Step 5: 전체 디코딩 로직
───────────────────────
FIBONACCI = [1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233]

# 비트스트림 생성
bitstream = ""
for num in NUMBERS:
    bitstream += bin(num)[2:].zfill(8)

# 디코딩
decoded = []
for i in range(FLAG_LEN):
    start = i * 12
    end = start + 12
    bits_str = bitstream[start:end]
    
    # Zeckendorf 변환
    value = 0
    for j in range(len(FIBONACCI)):
        if int(bits_str[j]) == 1:
            value += FIBONACCI[j]
    
    decoded.append(chr(value))

flag = ''.join(decoded)
print(flag)

【 핵심 개념 】
1. Zeckendorf 정리 (Zeckendorf Theorem)
   - 연속되지 않는 피보나치 수의 합으로 정수 표현
   - 각 표현은 유일함
   
2. 비트 인코딩
   - 8비트씩 묶여있는 NUMBERS 배열
   - 이들을 연결하여 하나의 비트스트림 생성
   
3. 비트 마스킹
   - 12비트씩 분리하여 각 위치의 비트 확인
   - 1인 위치의 피보나치 수를 합산

================================================================================
                        4. Redeem Code 문제
================================================================================

【 문제 설명 】
JWT + Bcrypt 기반의 토큰 검증 시스템에서 취약한 ADMIN_SECRET을 이용하여
VIP 토큰을 위조하고 플래그를 획득하는 문제입니다.

【 플래그 】
runa2025{bcrypt_truncation_ftw}

【 토큰 구조 】
base64url(payload) . base64url(salt) . base64url(signature)

예시:
eyJyb2xlIjoiICA...  . Y2FsY3VsYXRlZHzs.  . $2b$10$hash...

【 풀이 과정 】

Step 1: 샘플 토큰 획득
────────────────────
import requests

r = requests.get("http://server/sample_user", timeout=5)
token = r.json()["token"]
print(f"Token: {token}")

p_b64, s_b64, h_b64 = token.split('.')

Step 2: 토큰 디코딩
─────────────────
import base64
import json

def b64u_decode(s):
    """Base64 URL-safe 디코딩"""
    s += '=' * (4 - len(s) % 4)
    return base64.urlsafe_b64decode(s)

payload_bytes = b64u_decode(p_b64)
salt = b64u_decode(s_b64)
sig = b64u_decode(h_b64)

payload = json.loads(payload_bytes)
print(f"Payload: {payload}")
# {'email': 'user@example.com', 'role': 'user', 'iat': ..., 'exp': ...}

Step 3: 취약점 발견
─────────────────
서버 코드에서:
    ADMIN_SECRET = b''  # 빈 문자열!
    
    def sign_payload(payload_bytes, salt):
        msg = payload_bytes + b'.' + ADMIN_SECRET
        return bcrypt.hashpw(msg, salt)

→ ADMIN_SECRET이 빈 문자열이므로 salt만 알면 서명 위조 가능!

Step 4: VIP 페이로드 생성
───────────────────────
import time

vip_payload = {
    "email": "user@example.com",
    "role": "vip",  # user → vip로 변경 (핵심)
    "iat": int(time.time()),
    "exp": int(time.time()) + 3600
}

vip_payload_bytes = json.dumps(vip_payload, separators=(',', ':')).encode()

Step 5: 서명 생성
────────────────
import bcrypt

ADMIN_SECRET = b''  # 알려진 값
msg = vip_payload_bytes + b'.' + ADMIN_SECRET

# 원래 토큰에서 얻은 salt 사용
new_sig = bcrypt.hashpw(msg, salt)

Step 6: VIP 토큰 조립
───────────────────
def b64u_encode(b):
    """Base64 URL-safe 인코딩"""
    return base64.urlsafe_b64encode(b).decode().rstrip('=')

vip_token = '.'.join([
    b64u_encode(vip_payload_bytes),
    b64u_encode(salt),
    b64u_encode(new_sig)
])

print(f"VIP Token: {vip_token}")

Step 7: 플래그 획득
─────────────────
r = requests.post("http://server/redeem", 
    json={"token": vip_token}, 
    timeout=5)

capsule = b64u_decode(r.json()["capsule"])

# XOR 복호화
import hashlib

key = hashlib.sha256(vip_token.encode()).digest()

def xor_repeat(data, key):
    return bytes(d ^ key[i % len(key)] for i, d in enumerate(data))

flag = xor_repeat(capsule, key).decode()
print(f"Flag: {flag}")

【 핵심 개념 】
1. JWT 토큰 구조와 검증
   - Header . Payload . Signature 형식
   - Signature 검증이 보안의 핵심
   
2. Bcrypt의 salt 기반 해싱
   - salt는 공개되어도 괜찮음
   - ADMIN_SECRET이 보안의 핵심
   
3. 취약한 보안 설정
   - ADMIN_SECRET = b'' (빈 문자열)은 치명적
   - 충분한 엔트로피를 가진 랜덤 값 필수
   
4. Base64 URL-safe 인코딩/디코딩
   - '+' → '-', '/' → '_'로 변환
   - 패딩('=')은 디코딩 후 제거

================================================================================
                         5. Shototsu 문제
================================================================================

【 문제 설명 】
MD4 해시 함수의 충돌(collision)을 찾는 문제입니다.
서버가 제시한 기본 충돌과는 다른 새로운 충돌을 찾아야 합니다.

【 플래그 】
runa2025{md4_collision_is_really_danger_crypt0system_and_so_many_pair}

【 풀이 과정 】

Step 1: 문제 이해
────────────────
서버에서 제공하는 기본 충돌:
t1 = 0x839c7a4d7a92cbd678a5d529eea5a7573c8a74deb366c3dc20a083b69f5d2a3bb3719dc69891e9f95e809fd7e8b23ba6318edc45e51fe39708bf9427e9c3e8b
t2 = 0x839c7a4d7a92cb5678a5d5b9eea5a7573c8a74deb366c3dc20a083b69f5d2a3bb3719dc69891e9f95e809fd7e8b23ba6318edd45e51fe39708bf9427e9c3e8b

확인: encrypt(t1) == encrypt(t2)
→ 3바이트만 다름 (위치 7, 11, 50)

Step 2: 충돌 확장 아이디어
───────────────────────
초기 시도 (실패):
- 무작위 2바이트 flip으로 새로운 충돌 찾기 → 백만 번 시도했으나 실패

돌파구:
- MD4는 64바이트 블록 단위 처리
- 원본 충돌에 동일한 바이트를 추가하면?
  encrypt(t1) == encrypt(t2) 이면
  encrypt(t1 + x) == encrypt(t2 + x) 도 성립!

Step 3: 충돌 생성 및 검증
────────────────────────
t1_bytes = bytes.fromhex("839c7a4d7a92cbd678a5d529eea5a7573c8a74deb366c3dc20a083b69f5d2a3bb3719dc69891e9f95e809fd7e8b23ba6318edc45e51fe39708bf9427e9c3e8b")
t2_bytes = bytes.fromhex("839c7a4d7a92cb5678a5d5b9eea5a7573c8a74deb366c3dc20a083b69f5d2a3bb3719dc69891e9f95e809fd7e8b23ba6318edd45e51fe39708bf9427e9c3e8b")

# 원본 충돌 확인
from prob import encrypt
assert encrypt(t1_bytes) == encrypt(t2_bytes)

# 새로운 충돌 생성
m1 = t1_bytes + b'\x00'
m2 = t2_bytes + b'\x00'

# 검증
assert encrypt(m1) == encrypt(m2)  # True (새로운 충돌!)
assert m1 != m2                     # True
assert m1 != t1_bytes              # True
assert m1 != t2_bytes              # True

Step 4: 서버에 제출
─────────────────
import socket

def submit_collision(m1, m2):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect(('crypto.runa2025.kr', 6006))
    
    # 초기 응답 수신
    s.recv(1024)
    
    # m1 제출 (16진수 문자열)
    s.send((m1.hex() + '\n').encode())
    s.recv(1024)
    
    # m2 제출
    s.send((m2.hex() + '\n').encode())
    response = s.recv(16384)
    
    s.close()
    return response.decode()

flag = submit_collision(m1, m2)
print(flag)

Step 5: 플래그 획득
─────────────────
Flag: runa2025{md4_collision_is_really_danger_crypt0system_and_so_many_pair}

【 제출된 충돌 】
m1 = ...8b 900
m2 = ...8b 900
(원본 충돌에 0x00 추가)

【 핵심 개념 】
1. MD4의 약점
   - 1997년에 충돌 발견
   - 완전히 새로운 충돌을 찾기는 어렵지만, 기존 충돌을 확장하기는 쉬움
   
2. 메시지 확장을 통한 충돌 유지
   - 동일한 바이트를 추가하면 충돌이 유지됨
   - 이는 해시 함수의 특성을 이용한 기법
   
3. MD4는 절대 사용하면 안 됨
   - 보안 목적으로 SHA-256 등의 현대적 해시 함수 사용
   
4. "쉬운" 문제의 의미
   - 완전히 새로운 공격을 찾기보다, 주어진 정보 활용이 핵심
   - 서버가 제시한 기본 충돌을 이용하여 문제 단순화

================================================================================
                             마무리
================================================================================

5개 문제 모두 성공적으로 완성했습니다:

1. ✅ P2PE (PE 파일 복구) - 기본 파일 포맷 이해
2. ✅ GET out of there! (HTTP 헤더) - 프로토콜 분석
3. ✅ Zeckendorf (피보나치 인코딩) - 수학적 알고리즘
4. ✅ Redeem Code (토큰 위조) - 암호학적 취약점
5. ✅ Shototsu (MD4 충돌) - 해시 함수의 약점

각 문제별 핵심 학습 포인트:
- PE 파일 포맷의 구조와 복구
- HTTP 프로토콜의 메서드 차이
- Zeckendorf 정리와 비트 인코딩
- JWT와 Bcrypt의 보안 설정
- 해시 함수의 암호학적 분석

================================================================================
